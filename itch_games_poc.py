from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.common.exceptions import NoSuchElementException
from selenium.common.exceptions import StaleElementReferenceException
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
import os
import csv
import zipfile, tarfile
from rarfile import RarFile
import time

# function to take care of downloading file
def enable_download_headless(browser,download_dir):
    browser.command_executor._commands["send_command"] = ("POST", '/session/$sessionId/chromium/send_command')
    params = {'cmd':'Page.setDownloadBehavior', 'params': {'behavior': 'allow', 'downloadPath': download_dir}}
    browser.execute("send_command", params)

# instantiate a chrome options object so you can set the size and headless preference
# some of these chrome options might be uncessary but I just used a boilerplate
# change the <path_to_download_default_directory> to whatever your default download folder is located
chrome_options = Options()
#chrome_options.add_argument("--headless")
chrome_options.add_argument("--window-size=1920x1080")
chrome_options.add_argument("--disable-notifications")
chrome_options.add_argument('--no-sandbox')
chrome_options.add_argument('--verbose')
chrome_options.add_experimental_option("prefs", {
        "download.default_directory": "/Users/esthergoldstein/Downloads",
        "download.prompt_for_download": False,
        "download.directory_upgrade": True,
        "safebrowsing_for_trusted_sources_enabled": True,
        "safebrowsing.enabled": True
})


# initialize driver object and change the <path_to_chrome_driver> depending on your directory where your chromedriver should be
driver = webdriver.Chrome(chrome_options=chrome_options, executable_path="/Users/esthergoldstein/itchingtofindsomemalware/chromedriver")

# change the <path_to_place_downloaded_file> to your directory where you would like to place the downloaded file
download_dir = "/Users/esthergoldstein/itchingtofindsomemalware/downloads"

# function to handle setting up headless download
enable_download_headless(driver, download_dir)
with open('itch_games_windows.csv', mode='r') as game_info_file:
    reader = csv.reader(game_info_file, delimiter=' ', quotechar='"', quoting=csv.QUOTE_MINIMAL)
    line_count = 1
    prev_url = ""
    url = ""
    num_tabs = 1
    next(reader) # headings

    for data_row in reader: # insert number of pages for Itch.io
        # want to check if files exist in cur dir so we know if it downloaded
        num_files_in_dir = len([name for name in os.listdir('/Users/esthergoldstein/itchingtofindsomemalware/downloads')]);
        # print("num files in dir: " + str(num_files_in_dir))
        if num_files_in_dir != line_count:
            print(prev_url + " did not download")
        else:
            line_count = line_count + 1
        if line_count == 20:
            break

        prev_url = url
        url = data_row[2]
        driver.get(url)
        # print(url)
        
        download_button_path = "//a[contains(@class, 'buy_btn') or contains(@class, 'download_btn')]"
        wait = WebDriverWait(driver, 10)
        download_button = wait.until(EC.presence_of_element_located((By.XPATH, download_button_path)))
        el = driver.find_element_by_xpath(download_button_path)
        href = el.get_attribute('href')
        if not "javascript:void(0)" in href:
            # this is if it's "name your own price"
            driver.get(href)
        else:
            download_button = driver.find_element_by_xpath(download_button_path)
            driver.execute_script("arguments[0].scrollIntoView();", download_button);
            download_button = driver.find_element_by_xpath(download_button_path)
            download_button.click()
            # need to wait after clicking before navigating to next page
            time.sleep(2)
            continue
        try:
            wait = WebDriverWait(driver, 10)
            download_button = wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, "a[class='direct_download_btn']")))
            download_button = driver.find_element_by_css_selector("a[class='direct_download_btn']")
            driver.execute_script("arguments[0].scrollIntoView();", download_button);
            download_button = driver.find_element_by_css_selector("a[class='direct_download_btn']")
            download_button.click()
            time.sleep(1)
        except BaseException as e:
            print("exception for " + url)
            print(e)
            continue
        try:
            # if the driver.window_handles array (aka # tabs) has more than one entry, 
            # it means that the previous URL opened a new tab (probably a Google Drive link)
            # close tab and note that previous URL didn't download
            if len(driver.window_handles) > num_tabs:
                driver.switch_to.window(driver.window_handles[0])
                num_tabs = num_tabs + 1
                print(prev_url + " did not download")

            # need to wait after clicking before navigating to next page
            wait = WebDriverWait(driver, 10)
            download_button = wait.until(EC.presence_of_element_located((By.XPATH, download_button_path)))
            driver.execute_script("arguments[0].scrollIntoView();", download_button);
            download_button = driver.find_element_by_xpath(download_button_path)
            download_button.click()
            time.sleep(3)
        except BaseException as e:
            print("exception for " + url)
            print(e)
            continue


