import virustotal_api
import os
import time # so we can avoid exceeding the VirusTotal quotas
import json
import getopt, sys

# Global config variables. I know it's gross I'll fix it later I promise.
debug = True

# 32 MB
big_file_size = 32000000
# 400 MB
too_big_file_size = 300000000

# MAX REQUEST RATE: 4 per minute (post and get!)

# TODOs:
# - I suspect that I'm getting a json decoding error for games with quotes
# in their names. How deal with that? Rename the executable?
# - detect that a file is too large before uploading it for efficiency lol

# This script should be in the same folder as the folders:
# 	itch_download
#	itch_extract *
#	steam_downlod
#	steam_extract
def main():
	print("*****************")
	print("Welcome to your game malware detection companion!\n")

	options = parse_args()
	folder = options[0]
	apikey_index = options[1]

	setup(folder)

	if 'u' in options:
		print ("\nBeginning upload.\n")
		upload_folder(folder, apikey_index)
	if 'd' in options:
		print ("\nBeginning download.\n")
		download_folder(folder, apikey_index)

	print("*****************")


'''
Parses arguments, setting confguration of which chunks to run.
'''
def parse_args():
	folder = 'itch_extract' # default
	argumentList = sys.argv[1:]

	unixOptions = "f:udvk:"
	gnuOptions = ["folder=", "upload", "download", "verbose", "key"]
	config = [folder, 0]

	try:
		arguments, values = getopt.getopt(argumentList, unixOptions, gnuOptions)
	except getopt.error as err:
		# output error, and return with an error code
		print (str(err))
		sys.exit(2)

	for currentArgument, currentValue in arguments:
		if currentArgument in ("-u", "--upload"):
			print ("Uploading all games in specified folder.")
			config.append('u')
		elif currentArgument in ("-d", "--download"):
			print ("Downloading stats for all games in specified log file.")
			config.append('d')
		elif currentArgument in ("-f", "--folder"):
			print (("Targeting specific folder (%s)") % (currentValue))
			config[0] = currentValue
		elif currentArgument in ("-v", "--verbose"):
			print ("Printing debug information.")
			debug = True
		elif currentArgument in ("-k", "--key"):
			print ("Using api key (%s)" % (currentValue))
			config[1] = (int(currentValue))

	return config

'''
If a log folder doesn't already exist, make one.
'''
def setup(folder):
	log_folder_path = os.getcwd() + '/' + folder + '_logs'
	if not os.path.exists(log_folder_path):
		os.makedirs(log_folder_path)

def log_file_path(folder, logtype):
	return os.getcwd() + '/' + folder + '_logs' + '/' + folder + logtype

'''
Read in a log file from previous runs of this script.
'''
def parse_log(folder, name):
	log_path = log_file_path(folder, name)
	log_dict = {}
	with open(log_path, 'r') as log:
		for line in log:
			# split each line by the delimiter
			line_parts = line.split(' :== ')
			if len(line_parts) == 2:
				log_dict[line_parts[0]] = line_parts[1]

	return log_dict

'''
Wrapper function for uploading.
'''
def upload_folder(folder, apikey_index):
	print("Detecting log file for folder " + folder)
	if not os.path.exists(log_file_path(folder, '_log.txt')):
		print("- Log file not found; finding and uploading exes")
		upload_exes(folder, {}, apikey_index)
	else:
		print("- Log file found; continuing where it left off")
		log_dict = parse_log(folder, '_log.txt')
		upload_exes(folder, log_dict, apikey_index)

'''
Iterate through all folders in the given top level folder and
upload the first exe found in each of them to VirusTotal,
writing out the corresponding resource names to a file.

past_jobs is a dictionary of all the resource keys we already got
from past runs. We want to ignore those.
'''
def upload_exes(folder_name, past_jobs, apikey_index):
	cwd = os.getcwd()
	folder = '/' + folder_name + '/'

	blacklist = []
	with open(log_file_path(folder_name, '_blacklist.txt'), 'a+') as bl:
		for line in bl:
			blacklist.append(line.strip())
	if (debug): print("Blacklist: " + str(blacklist) + "\n")

	# Loop over everything in that folder
	itch_folders = os.listdir(cwd + folder)
	if (debug):
		print("Games to post:")
		print(itch_folders)
		print('')

	with open(log_file_path(folder_name, '_log.txt'), 'a+') as log:
		with open(log_file_path(folder_name, '_exes.txt'), 'a+') as exes:
			# Keep a map from folder names to resource keys
			itch_resource_keys = {}
			for game in itch_folders:
				if game in blacklist:
					print("* " + game + " found in blacklist. Continuing\n")
					continue

				if game in past_jobs:
					itch_resource_keys[game] = past_jobs[game]
					print("* " + game + " found in log. Continuing\n")
					continue

				if (debug): print(game)

				path = cwd + folder + game
				exe_path = find_exe_path(path)
				if (exe_path == 'No path'):
					print("* No exe found for " + game + "\n")
					add_to_blacklist(folder_name, game, 'No exe found')
					continue
				else:
					exes.write(game + " ::= " + os.path.basename(exe_path) + '\n')

				# It's possible we'll run into a weird socket error - we want
				# the script to continue regardless!
				try:
					size = os.path.getsize(exe_path)
					print("size: " + str(size))
					if (size < big_file_size):
						resource = virustotal_api.post_file(exe_path, apikey_index)
					elif (size > too_big_file_size):
						print("* File too big for upload; skipping")
						add_to_blacklist(folder_name, game, 'Too big for upload')
						continue
					else:
						print("Big file!")
						resource = virustotal_api.post_big_file(exe_path, apikey_index, 0.12)
				except IOError as ioe:
					print("* An IOError occurred. Adding to blacklist")
					print(ioe)
					print()
					add_to_blacklist(folder_name, game, 'IOError - ' + str(ioe))
					continue
				except json.decoder.JSONDecodeError:
					print("* A JSONDecodeError occurred. Adding to blacklist\n")
					add_to_blacklist(folder_name, game, 'JSONDecodeError')
					sleep()
					continue
				except virustotal_api.TooBigError:
					print("* File too big! Noting in retry manual list\n")
					add_to_manual(folder_name, game)
					add_to_blacklist(folder_name, game, 'File too big') # add to both so we don't keep retrying
					sleep()
					continue

				itch_resource_keys[game] = resource
				log.write(game + ' :== ' + resource + '\n')

				if (debug): print(resource)

				sleep()

	# Write map out to file
	with open(log_file_path(folder_name, '_dump.txt'), 'w') as file:
		file.write(json.dumps(itch_resource_keys))


def sleep():
	print("* Sleeping for 0.06s (bless academic rates)\n")
	time.sleep(0.12) # rate limit us to just below 1000

'''
Add a game to the manual file
'''
def add_to_manual(folder_name, game):
	with open(log_file_path(folder_name, '_manual.txt'), 'a+') as m:
		m.write(game + '\n')

'''
Add a game to the blacklist file
'''
def add_to_blacklist(folder_name, game, error=''):
	with open(log_file_path(folder_name, '_blacklist.txt'), 'a+') as bl:
		bl.write(game + '\n')
	if error != '':
		with open(log_file_path(folder_name, '_error_log.txt'), 'a+') as el:
			el.write(game + ': ' + error + '\n')


'''
Given a path to a higher level folder, find the likely exe.
'''
def find_exe_path(folder_path):
	# Walk recursively downwards until you find an exe.
	folder_path += '/'
	extensions = ['.exe', '.bin', '.jar', '.lua', '.apk', '.unity', '.unity3d',
				  '.app', '.x86', '.caproj', '.AppImage', '.quest', '.odp',
				  '.uproject', '.py', '.quest', '.sb2', '.sb3', '.bat', '.html',
				  '.xlsm', '.ppsx', '.love', '.bat', '.pck', '.msi', '.pptx',
				  '.p8', '.pde', '.yyp', '.gm81', '.yyp', '.gmz', '.dmg',
				  '.webloc', '.el', '.livecode', '.EXE',
				  '.aslx', '.blend', '.swf', '.stencyl', '.z80', '.gblorb',
				  '.vbs', '.json', '.rpgproject', '.ps1', '.PNG', '.dll',
				  '.iso', '.mfa', '.js', '.tar.bz2', '.tap', '.tar.bz',
				  '.rbxl', '.zip', '.7z', '.tar.xz', '.RAR', '.rar', '.sb2',
				  '.pdf', '.txt', '.wav', '.mp4']

	for ext in extensions:
		for (dirpath, dirnames, filenames) in os.walk(folder_path):
			for name in filenames:
				if ext in name:
					# Skip over unity crash handler exes
					if 'UnityCrashHandler' in name or 'CrashReportClient' in name:
						continue
					print("* Found: " + name)
					return dirpath + '/' + name

	return 'No path'


def download_folder(folder, apikey_index):
	print("Detecting log file for folder " + folder)
	if not os.path.exists(log_file_path(folder, '_stats.txt')):
		print("- Log file not found; downloading all stats")
		parse_dump(folder, {}, apikey_index)
	else:
		print("- Log file found; continuing where it left off")
		log_dict = parse_log(folder, '_stats.txt')
		parse_dump(folder, log_dict, apikey_index)


'''
Read in a dump file. Retrieve the VirusTotal stats for each of the files and output
them to an output file.
'''
def parse_dump(folder_name, past_jobs, apikey_index):
	print("")
	with open(log_file_path(folder_name, '_dump.txt'), mode='r') as dump_file:
		dump = dump_file.read()
		resource_keys = json.loads(dump)

	with open(log_file_path(folder_name, '_stats.txt'), 'a+') as log:
		for game in resource_keys:
			if game in past_jobs:
				print ("* " + game + " found in stats. Continuing\n")
				continue

			try:
				result = virustotal_api.check_file(resource_keys[game], apikey_index)
				# print(result)
				if (debug): print(game + ": " + str(result['positives']) + '\n')
				log.write(game + " :== " + str(result) + '\n')
			except json.decoder.JSONDecodeError:
				print("* Error decoding JSON response - adding to retry list")
				add_to_retrylist(folder_name, game)
			except IOError:
				print("* IOError - adding to retry list")
				add_to_retrylist(folder_name, game)

			sleep()

'''
Add a game to the retry list
'''
def add_to_retrylist(folder_name, game):
	with open(log_file_path(folder_name, '_retry.txt'), 'a+') as bl:
		bl.write(game + '\n')

if __name__== "__main__":
  main()